# Prover
## Overview
The **Silvana Prover** is directly related to **Zero-Knowledge Proof (ZKP)** technology. It produces cryptographic proofs that confirm the validity of statements or transitions in Provable Records while preserving the confidentiality of the underlying sensitive information. 

Its functionality is essential, like the engine in a car, making it a critical driver of the entire system. Without a prover, the purpose and functionality of Silvana is fundamentally compromised. Utilizing zero-knowledge technology, Silvana ensures secure and private transactions without compromising data integrity or compliance.


> **Note!**  
>
> The **Silvana Prover** is component of the Silvana Core architecture, responsible for generating zero-knowledge proofs (ZKPs) validating state mutations of Provable Records. It ensures transaction validity and privacy without exposing underlying sensitive data.

Specifically, Silvana Prover utilizes **zk-SNARK** systems, including **Groth16** and **PLONK**. The PLONK variant implemented is **Kimchi**, adopted via the **o1js** library, which supports universal circuits and requires no trusted setup.

For cryptographic hashing, Silvana uses **Poseidon** within zk-circuits due to its efficiency in SNARK environments. **BLAKE2** is also supported for compatibility with external systems.

## Prover and Verifier Functions
### Prover
The Prover retrieves **schema** and logic (**zkProgram**) from the **Router**, as well as the current state of provable records from the **Data Availability (DA)** layer. It then processes the collected inputs according to the zkProgram logic, executing cryptographic operations to generate proofs. These proofs cryptographically confirm the correctness and compliance of the state transitions without disclosing any sensitive or private details involved in the transactions.

```
async function generateProverProof(privateInput, publicInput, zkProgram) {
  const proverKeys = await generateProverKeys(zkProgram);
  const proof = await zkProgram.execute(privateInput, publicInput, proverKeys);
  return proof;
}
```

### Verifier
The Verifier independently **checks the proofs** generated by the **Prover**, ensuring they adhere strictly to the schema and zkProgram logic. This verification process confirms the accuracy of the proofs and guarantees that the provable recordsâ€™ transitions comply with defined rules and constraints, while maintaining confidentiality of sensitive data.

## How Prover Works

The Silvana Prover details a structured approach to generating and managing zero-knowledge proofs (ZKPs), ensuring secure and confidential verification of state changes without revealing sensitive data. Beginning with transaction initiation, the **Prover** retrieves required data and schemas from the **Router** and **Data Availability (DA) layer**. It then executes cryptographic operations defined by the zkProgram to generate verifiable proofs. These proofs are securely stored and submitted to the blockchain for validation and settlement. The flow also covers proof reservation, merging proofs for efficiency, and managing on-chain settlements, ensuring robust and compliant proof handling within the Silvana system.

![Silvana Prover Flow](../img/prover-flow.png)
 
 ### Prover Flow
The Prover flow consists of the following steps:

1. **Initiation**:
   - User or system initiates a transaction involving a **provable record**.
   - **DA Layer** queried for existing provable record state.

2. **State Validation**:
   - Blockchain node queried on **Settlement Layer** to verify current state integrity.

3. **Input Collection**:
   - System collects necessary **Private and Public input**s required for proof generation.

4. **Preparation**:
   - **ABI** retrieves the relevant **zkProgram** and module logic for the transaction.

5. **Transaction Building**:
   - **Tx Builder** constructs the ZKP transaction and forwards it to the Prover.

6. **Key Generation**:
   - **Tx Compiler** generates the cryptographic keys necessary for the Prover.

7. **Proof Generation**:
   - **Prover** executes the zkProgram with provided inputs, producing a cryptographic proof.

8. **Proof Submission**:
   - **Tx Sender** submits the transaction and associated ZK proof to the blockchain for consensus.

9. **Transaction Hashing**:
   - Blockchain nodes process and generate a transaction hash.

10. **Monitoring & Status Update**:
    - **Tx Sender** communicates the transaction hash to **Tx Monitor**.
    - **Tx Monitor** queries the transaction status using **Indexer API**.

11. **State & Index Update**:
    - Tx Monitor updates the object state in the DA Layer and indexer databases via zkProver API.

12. **Final Status Update**:
    - Transaction status is recorded in the **Router database**.
    - Client systems can verify the transaction status through appropriate interfaces.


## Integration and Compatibility

Silvana Prover operates within a flexible, modular architecture compatible with various execution environments (**PXE, CXE, TEE**) and blockchain networks (**L1, L2**). It is blockchain-agnostic, supporting chains such as Ethereum, Sui, Solana, and Mina.

## Prover Operations Handling

The Silvana Prover manages ongoing operations to ensure optimal resource utilization and consistent transaction processing:

* **Concurrent Processing**: Manages proof generation and submission concurrently, ensuring efficient utilization of computing resources.

* **Error Handling**: Systematically handles and logs errors during proof reservation, generation, and submission phases, ensuring reliability.


